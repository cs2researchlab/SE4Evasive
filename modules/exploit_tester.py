"""
SymbolicHunter Exploit Testing Module
Automatically tests generated exploits and confirms vulnerabilities
"""

import subprocess
import os
import tempfile
import signal
from datetime import datetime
import json

class ExploitTester:
    def __init__(self, binary_path, timeout=5, sandbox=True):
        """
        Initialize exploit tester
        
        Args:
            binary_path: Path to binary to test
            timeout: Timeout for each test in seconds
            sandbox: Enable sandboxing (recommended)
        """
        self.binary_path = binary_path
        self.timeout = timeout
        self.sandbox = sandbox
        self.results = []
    
    def test_exploit(self, exploit_input, description=""):
        """
        Test a single exploit input
        
        Args:
            exploit_input: Bytes to send as input
            description: Description of the exploit
        
        Returns:
            Dictionary with test results
        """
        result = {
            'description': description,
            'input_size': len(exploit_input),
            'timestamp': datetime.now().isoformat(),
            'crashed': False,
            'exit_code': None,
            'stdout': None,
            'stderr': None,
            'timeout_exceeded': False,
            'signal': None
        }
        
        # Create temporary input file
        with tempfile.NamedTemporaryFile(delete=False, suffix='.bin') as tmp:
            tmp.write(exploit_input)
            tmp_path = tmp.name
        
        try:
            # Run the binary with exploit input
            process = subprocess.Popen(
                [self.binary_path],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                preexec_fn=os.setsid if os.name != 'nt' else None
            )
            
            try:
                stdout, stderr = process.communicate(
                    input=exploit_input,
                    timeout=self.timeout
                )
                result['stdout'] = stdout[:500]  # First 500 bytes
                result['stderr'] = stderr[:500]
                result['exit_code'] = process.returncode
                
                # Check if crashed (negative exit code or signal)
                if process.returncode < 0:
                    result['crashed'] = True
                    result['signal'] = -process.returncode
                
            except subprocess.TimeoutExpired:
                result['timeout_exceeded'] = True
                # Kill the process
                if os.name != 'nt':
                    os.killpg(os.getpgid(process.pid), signal.SIGKILL)
                else:
                    process.kill()
                process.wait()
        
        except Exception as e:
            result['error'] = str(e)
        
        finally:
            # Clean up temp file
            try:
                os.unlink(tmp_path)
            except:
                pass
        
        self.results.append(result)
        return result
    
    def test_multiple_exploits(self, exploits):
        """
        Test multiple exploits
        
        Args:
            exploits: List of dictionaries with 'input' and 'description'
        
        Returns:
            Summary of test results
        """
        print(f"[*] Testing {len(exploits)} exploits...")
        
        crashed = 0
        timeout = 0
        completed = 0
        
        for i, exploit in enumerate(exploits, 1):
            print(f"[*] Test {i}/{len(exploits)}: {exploit.get('description', 'Unknown')}")
            
            result = self.test_exploit(
                exploit['input'],
                exploit.get('description', f'Exploit {i}')
            )
            
            if result['crashed']:
                print(f"    [!] CRASHED - Signal {result['signal']}")
                crashed += 1
            elif result['timeout_exceeded']:
                print(f"    [!] TIMEOUT - Possible infinite loop")
                timeout += 1
            else:
                print(f"    [+] Completed - Exit code {result['exit_code']}")
                completed += 1
        
        summary = {
            'total_tests': len(exploits),
            'crashed': crashed,
            'timeout': timeout,
            'completed': completed,
            'crash_rate': (crashed / len(exploits) * 100) if exploits else 0,
            'results': self.results
        }
        
        print(f"\n[*] Test Summary:")
        print(f"    Total tests: {summary['total_tests']}")
        print(f"    Crashed: {crashed} ({summary['crash_rate']:.1f}%)")
        print(f"    Timeout: {timeout}")
        print(f"    Completed: {completed}")
        
        return summary
    
    def generate_test_report(self, output_path):
        """Generate detailed test report"""
        report = {
            'binary': self.binary_path,
            'timestamp': datetime.now().isoformat(),
            'total_tests': len(self.results),
            'crashes': sum(1 for r in self.results if r['crashed']),
            'timeouts': sum(1 for r in self.results if r['timeout_exceeded']),
            'results': self.results
        }
        
        with open(output_path, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        return output_path
    
    def verify_vulnerability(self, exploit_candidates):
        """
        Verify vulnerabilities by testing exploits
        
        Args:
            exploit_candidates: List of exploit dictionaries
        
        Returns:
            List of confirmed vulnerabilities
        """
        confirmed = []
        
        for exploit in exploit_candidates:
            result = self.test_exploit(
                exploit['input'],
                exploit.get('description', 'Unknown')
            )
            
            # Vulnerability confirmed if crashed or behaved abnormally
            if result['crashed'] or result['timeout_exceeded']:
                confirmed.append({
                    'exploit': exploit,
                    'test_result': result,
                    'confirmed': True,
                    'severity': 'CRITICAL' if result['crashed'] else 'HIGH'
                })
        
        return confirmed


def test_exploits(binary_path, exploit_candidates, timeout=5):
    """
    Convenience function to test exploits
    
    Args:
        binary_path: Path to binary
        exploit_candidates: List of exploit dictionaries
        timeout: Timeout per test
    
    Returns:
        Test summary
    """
    tester = ExploitTester(binary_path, timeout=timeout)
    
    # Convert exploit candidates to test format
    exploits = [
        {
            'input': e.get('input', b''),
            'description': e.get('description', 'Unknown')
        }
        for e in exploit_candidates
    ]
    
    return tester.test_multiple_exploits(exploits)
